
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>multi_edge &#8212; graynet 0.4.5 documentation</title>
    <link rel="stylesheet" href="../_static/pd.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <script type="text/javascript" src="../_static/pd.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

  </head><body>
    <div id="header">
        <h1>graynet 0.4.5 documentation</h1>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
        <ul>
            <li class="nav-item nav-item-0"><a href="../index.html">graynet 0.4.5 documentation</a> &#187;
            </li>
                <li class="nav-item nav-item-1"><a href="index.html"
                        accesskey="U">Module code</a> &#187;</li>
        </ul>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
<h1>Source code for multi_edge</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">graynet.utils</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;extract_multiedge&#39;</span><span class="p">,</span> <span class="s1">&#39;summarize_multigraph&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span> <span class="k">as</span> <span class="n">pjoin</span><span class="p">,</span> <span class="n">exists</span> <span class="k">as</span> <span class="n">pexists</span><span class="p">,</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">realpath</span><span class="p">,</span> <span class="n">getsize</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">hiwenet</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">version_info</span>

<span class="k">if</span> <span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">graynet.utils</span> <span class="k">import</span> <span class="n">stamp_expt_multiedge</span><span class="p">,</span> <span class="n">check_params_multiedge</span><span class="p">,</span> <span class="n">make_output_path_graph</span><span class="p">,</span> \
        <span class="n">save_graph</span><span class="p">,</span> <span class="n">check_subjects</span><span class="p">,</span> <span class="n">check_stat_methods</span><span class="p">,</span> <span class="n">check_num_bins</span><span class="p">,</span> <span class="n">check_weights</span><span class="p">,</span> \
        <span class="n">check_num_procs</span><span class="p">,</span> <span class="n">check_atlas</span><span class="p">,</span> <span class="n">check_edge_range_dict</span><span class="p">,</span> <span class="n">mask_background_roi</span><span class="p">,</span> <span class="n">warn_nan</span><span class="p">,</span> \
        <span class="n">stamp_expt_weight</span><span class="p">,</span> <span class="n">import_features</span><span class="p">,</span> <span class="n">save_per_subject_graph</span>
    <span class="kn">from</span> <span class="nn">graynet</span> <span class="k">import</span> <span class="n">parcellate</span>
    <span class="kn">from</span> <span class="nn">graynet</span> <span class="k">import</span> <span class="n">config_graynet</span> <span class="k">as</span> <span class="n">cfg</span>
    <span class="kn">from</span> <span class="nn">graynet</span> <span class="k">import</span> <span class="n">run_workflow</span> <span class="k">as</span> <span class="n">single_edge</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s1">&#39;graynet supports only Python 2.7 or 3+. Upgrade to Python 3+ is recommended.&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="extract_multiedge"><a class="viewcode-back" href="../API.html#multi_edge.extract_multiedge">[docs]</a><span class="k">def</span> <span class="nf">extract_multiedge</span><span class="p">(</span><span class="n">subject_id_list</span><span class="p">,</span>
                      <span class="n">input_dir</span><span class="p">,</span>
                      <span class="n">base_feature_list</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_features_multi_edge</span><span class="p">,</span>
                      <span class="n">weight_method_list</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_weight_method</span><span class="p">,</span>
                      <span class="n">summary_stats</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">multi_edge_summary_func_default</span><span class="p">,</span>
                      <span class="n">num_bins</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_num_bins</span><span class="p">,</span>
                      <span class="n">edge_range_dict</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">edge_range_predefined</span><span class="p">,</span>
                      <span class="n">atlas</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_atlas</span><span class="p">,</span>
                      <span class="n">smoothing_param</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_smoothing_param</span><span class="p">,</span>
                      <span class="n">node_size</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_node_size</span><span class="p">,</span>
                      <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">return_results</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">overwrite_results</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">num_procs</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">default_num_procs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts weighted networks (matrix of pair-wise ROI distances) based on multiple gray matter features based on Freesurfer processing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    subject_id_list : str or list</span>
<span class="sd">         must be path to a file containing subject IDs, or a list of subject IDs</span>
<span class="sd">    input_dir : str</span>
<span class="sd">        Path to the input directory where features can be read.</span>
<span class="sd">        For example, this can be Freesurfer&#39;s SUBJECTS_DIR, where output processing is stored.</span>
<span class="sd">        Or another directory with a structure that graynet can parse.</span>
<span class="sd">    base_feature_list : list</span>
<span class="sd">        Set of features that drive the different edges between the pair of ROIs.</span>

<span class="sd">        For example, if you choose thickness and pial_curv, each pair of ROIs will have two edges.</span>

<span class="sd">        This multi-edge network can be turned into a single network based on averaging weights from different individual networks.</span>

<span class="sd">    weight_method : string(s), optional</span>
<span class="sd">        Type of distance (or metric) to compute between the pair of histograms.</span>

<span class="sd">        It must be one of the following methods:</span>

<span class="sd">        - &#39;chebyshev&#39;</span>
<span class="sd">        - &#39;chebyshev_neg&#39;</span>
<span class="sd">        - &#39;chi_square&#39;</span>
<span class="sd">        - &#39;correlate&#39;</span>
<span class="sd">        - &#39;correlate_1&#39;</span>
<span class="sd">        - &#39;cosine&#39;</span>
<span class="sd">        - &#39;cosine_1&#39;</span>
<span class="sd">        - &#39;cosine_2&#39;</span>
<span class="sd">        - &#39;cosine_alt&#39;</span>
<span class="sd">        - &#39;euclidean&#39;</span>
<span class="sd">        - &#39;fidelity_based&#39;</span>
<span class="sd">        - &#39;histogram_intersection&#39;</span>
<span class="sd">        - &#39;histogram_intersection_1&#39;</span>
<span class="sd">        - &#39;jensen_shannon&#39;</span>
<span class="sd">        - &#39;kullback_leibler&#39;</span>
<span class="sd">        - &#39;manhattan&#39;</span>
<span class="sd">        - &#39;minowski&#39;</span>
<span class="sd">        - &#39;noelle_1&#39;</span>
<span class="sd">        - &#39;noelle_2&#39;</span>
<span class="sd">        - &#39;noelle_3&#39;</span>
<span class="sd">        - &#39;noelle_4&#39;</span>
<span class="sd">        - &#39;noelle_5&#39;</span>
<span class="sd">        - &#39;relative_bin_deviation&#39;</span>
<span class="sd">        - &#39;relative_deviation&#39;</span>

<span class="sd">        Note only the following are *metrics*:</span>

<span class="sd">        - &#39;manhattan&#39;</span>
<span class="sd">        - &#39;minowski&#39;</span>
<span class="sd">        - &#39;euclidean&#39;</span>
<span class="sd">        - &#39;noelle_2&#39;</span>
<span class="sd">        - &#39;noelle_4&#39;</span>
<span class="sd">        - &#39;noelle_5&#39;</span>

<span class="sd">        The following are *semi- or quasi-metrics*:</span>

<span class="sd">        - &#39;kullback_leibler&#39;</span>
<span class="sd">        - &#39;jensen_shannon&#39;</span>
<span class="sd">        - &#39;chi_square&#39;</span>
<span class="sd">        - &#39;chebyshev&#39;</span>
<span class="sd">        - &#39;cosine_1&#39;</span>
<span class="sd">        - &#39;chebyshev_neg&#39;</span>
<span class="sd">        - &#39;correlate_1&#39;</span>
<span class="sd">        - &#39;histogram_intersection_1&#39;</span>
<span class="sd">        - &#39;relative_deviation&#39;</span>
<span class="sd">        - &#39;relative_bin_deviation&#39;</span>
<span class="sd">        - &#39;noelle_1&#39;</span>
<span class="sd">        - &#39;noelle_3&#39;</span>

<span class="sd">        The following are  classified to be similarity functions:</span>

<span class="sd">        - &#39;histogram_intersection&#39;</span>
<span class="sd">        - &#39;correlate&#39;</span>
<span class="sd">        - &#39;cosine&#39;</span>
<span class="sd">        - &#39;cosine_2&#39;</span>
<span class="sd">        - &#39;cosine_alt&#39;</span>
<span class="sd">        - &#39;fidelity_based&#39;</span>

<span class="sd">        *Default* choice: &#39;manhattan&#39;.</span>

<span class="sd">    summary_stats : list of str</span>
<span class="sd">        A string, or list of strings, each representing a method (like &#39;median&#39;, &#39;prod&#39; or &#39;max&#39;),</span>
<span class="sd">        to compute a summay statistic from the array of multiple weights computed.</span>

<span class="sd">        This must be available as a member of numpy or scipy.stats.</span>

<span class="sd">    num_bins : int</span>
<span class="sd">        Number of histogram bins to use when computing pair-wise weights based on histogram distance. Default : 25</span>

<span class="sd">    edge_range_dict : tuple or list</span>
<span class="sd">        The range of edges (two finite values) within which to build the histogram e.g. ``--edge_range 0 5``.</span>
<span class="sd">        This can be helpful (and important) to ensure correspondence across multiple invocations of graynet (e.g. for different subjects), in terms of range across all bins as well as individual bin edges.</span>

<span class="sd">        Default :</span>

<span class="sd">            - ( 0.0, 5.0) for ``freesurfer_thickness`` and</span>
<span class="sd">            - (-0.3, 0.3) for ``freesurfer_curv``.</span>

<span class="sd">    atlas : str</span>
<span class="sd">        Name of the atlas whose parcellation to be used.</span>
<span class="sd">        Choices for cortical parcellation: [&#39;fsaverage&#39;, &#39;glasser2016&#39;], which are primary cortical.</span>
<span class="sd">        Volumetric whole-brain atlases will be added soon.</span>

<span class="sd">    smoothing_param : scalar</span>
<span class="sd">        Smoothing parameter, which could be fwhm for Freesurfer cortical features,</span>
<span class="sd">        or another relevant for the chosen base_feature_list.</span>
<span class="sd">        Default: assumed as fwhm=10mm for the default feature choice &#39;thickness&#39;</span>

<span class="sd">    node_size : scalar, optional</span>
<span class="sd">        Parameter to indicate the size of the ROIs, subparcels or patches, depending on type of atlas or feature.</span>
<span class="sd">        This feature is not implemented yet, just a placeholder and to enable default computation.</span>

<span class="sd">    out_dir : str, optional</span>
<span class="sd">        Path to output directory to store results.</span>
<span class="sd">        Default: None, results are returned, but not saved to disk.</span>
<span class="sd">        If this is None, return_results must be true.</span>

<span class="sd">    return_results : bool</span>
<span class="sd">        Flag to indicate whether to return the results to be returned.</span>
<span class="sd">        This flag helps to reduce the memory requirements, when the number of nodes in a parcellation or</span>
<span class="sd">        the number of subjects or weight methods are large, as it doesn&#39;t retain results for all combinations,</span>
<span class="sd">        when running from commmand line interface (or HPC). Default: False</span>
<span class="sd">        If this is False, out_dir must be specified to save the results to disk.</span>

<span class="sd">    overwrite_results : bool</span>
<span class="sd">        Flag to request overwriting of existing results, in case of reruns/failed jobs. By default, if the expected output file exists and is of non-zero size, its computation is skipped (assuming the file is complete, usable and not corrupted).</span>

<span class="sd">    num_procs : int</span>
<span class="sd">        Number of parallel processes to use to speed up computation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    edge_weights_all : dict, None</span>
<span class="sd">        If return_results is True, this will be a dictionary keyed in by a tuple: (weight method, subject_ID)</span>
<span class="sd">        The value of each edge_weights_all[(weight method, subject_ID)] is</span>
<span class="sd">        a numpy array of length p = k*(k-1)/2, with k = number of nodes in the atlas parcellation.</span>
<span class="sd">        If return_results is False, this will be None, which is the default.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># All the checks must happen here, as this is key function in the API</span>
    <span class="n">check_params_multiedge</span><span class="p">(</span><span class="n">base_feature_list</span><span class="p">,</span> <span class="n">input_dir</span><span class="p">,</span> <span class="n">atlas</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="p">,</span> <span class="n">node_size</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span>
                           <span class="n">return_results</span><span class="p">)</span>
    <span class="n">atlas</span> <span class="o">=</span> <span class="n">check_atlas</span><span class="p">(</span><span class="n">atlas</span><span class="p">)</span>

    <span class="n">subject_id_list</span><span class="p">,</span> <span class="n">num_subjects</span><span class="p">,</span> <span class="n">max_id_width</span><span class="p">,</span> <span class="n">nd_id</span> <span class="o">=</span> <span class="n">check_subjects</span><span class="p">(</span><span class="n">subject_id_list</span><span class="p">)</span>

    <span class="n">num_bins</span> <span class="o">=</span> <span class="n">check_num_bins</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    <span class="n">edge_range_dict</span> <span class="o">=</span> <span class="n">check_edge_range_dict</span><span class="p">(</span><span class="n">edge_range_dict</span><span class="p">,</span> <span class="n">base_feature_list</span><span class="p">)</span>
    <span class="n">weight_method_list</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">max_wtname_width</span><span class="p">,</span> <span class="n">nd_wm</span> <span class="o">=</span> <span class="n">check_weights</span><span class="p">(</span>
        <span class="n">weight_method_list</span><span class="p">)</span>

    <span class="c1"># validating the choice and getting a callable</span>
    <span class="n">summary_stats</span><span class="p">,</span> <span class="n">summary_stat_names</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">check_stat_methods</span><span class="p">(</span><span class="n">summary_stats</span><span class="p">)</span>

    <span class="n">num_procs</span> <span class="o">=</span> <span class="n">check_num_procs</span><span class="p">(</span><span class="n">num_procs</span><span class="p">)</span>
    <span class="n">pretty_print_options</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_id_width</span><span class="p">,</span> <span class="n">nd_id</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">max_wtname_width</span><span class="p">,</span> <span class="n">nd_wm</span><span class="p">)</span>

    <span class="c1"># roi_labels, ctx_annot = parcellate.freesurfer_roi_labels(atlas)</span>
    <span class="c1"># uniq_rois, roi_size, num_nodes = roi_info(roi_labels)</span>
    <span class="n">uniq_rois</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">roi_labels</span> <span class="o">=</span> <span class="n">parcellate</span><span class="o">.</span><span class="n">roi_labels_centroids</span><span class="p">(</span><span class="n">atlas</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Processing </span><span class="si">{}</span><span class="s1"> features resampled to </span><span class="si">{}</span><span class="s1"> atlas,&#39;</span>
          <span class="s1">&#39; smoothed at </span><span class="si">{}</span><span class="s1"> with node size </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base_feature_list</span><span class="p">,</span> <span class="n">atlas</span><span class="p">,</span>
                                                     <span class="n">smoothing_param</span><span class="p">,</span> <span class="n">node_size</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_results</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;When return_results=False, out_dir must be specified to be able to save the results.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pexists</span><span class="p">(</span><span class="n">out_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">out_dir</span><span class="p">)</span>

    <span class="n">partial_func_extract</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">per_subject_multi_edge</span><span class="p">,</span> <span class="n">input_dir</span><span class="p">,</span> <span class="n">base_feature_list</span><span class="p">,</span>
                                   <span class="n">roi_labels</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span>
                                   <span class="n">weight_method_list</span><span class="p">,</span> <span class="n">summary_stats</span><span class="p">,</span> <span class="n">summary_stat_names</span><span class="p">,</span>
                                   <span class="n">atlas</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="p">,</span> <span class="n">node_size</span><span class="p">,</span>
                                   <span class="n">num_bins</span><span class="p">,</span> <span class="n">edge_range_dict</span><span class="p">,</span>
                                   <span class="n">out_dir</span><span class="p">,</span> <span class="n">return_results</span><span class="p">,</span> <span class="n">overwrite_results</span><span class="p">,</span> <span class="n">pretty_print_options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_procs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_subjects</span> <span class="o">/</span> <span class="n">num_procs</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">Manager</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">num_procs</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">edge_weights_list_dicts</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">partial_func_extract</span><span class="p">,</span> <span class="n">subject_id_list</span><span class="p">,</span>
                                                   <span class="n">chunk_size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># reverting to sequential processing</span>
        <span class="n">edge_weights_list_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial_func_extract</span><span class="p">(</span><span class="n">subject</span><span class="o">=</span><span class="n">sub_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_id</span> <span class="ow">in</span>
                                   <span class="n">subject_id_list</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_results</span><span class="p">:</span>
        <span class="n">edge_weights_all</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">edge_weights_list_dicts</span><span class="p">:</span>
            <span class="c1"># each element from output of parallel loop is a dict keyed in by {subject, weight)</span>
            <span class="n">edge_weights_all</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge_weights_all</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">graynet computation done.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edge_weights_all</span></div>


<span class="k">def</span> <span class="nf">per_subject_multi_edge</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">base_feature_list</span><span class="p">,</span> <span class="n">roi_labels</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span>
                           <span class="n">weight_method_list</span><span class="p">,</span> <span class="n">summary_stats</span><span class="p">,</span> <span class="n">summary_stat_names</span><span class="p">,</span>
                           <span class="n">atlas</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="p">,</span> <span class="n">node_size</span><span class="p">,</span>
                           <span class="n">num_bins</span><span class="p">,</span> <span class="n">edge_range_dict</span><span class="p">,</span>
                           <span class="n">out_dir</span><span class="p">,</span> <span class="n">return_results</span><span class="p">,</span> <span class="n">overwrite_results</span><span class="p">,</span> <span class="n">pretty_print_options</span><span class="p">,</span>
                           <span class="n">subject</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># purposefully leaving it last to enable partial function creation</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts give set of weights for one subject.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">subject</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">return_results</span><span class="p">:</span>
        <span class="n">edge_weights_all</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge_weights_all</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">max_id_width</span><span class="p">,</span> <span class="n">nd_id</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span> <span class="n">max_wtname_width</span><span class="p">,</span> <span class="n">nd_wm</span> <span class="o">=</span> <span class="n">pretty_print_options</span>

    <span class="k">for</span> <span class="n">ww</span><span class="p">,</span> <span class="n">weight_method</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weight_method_list</span><span class="p">):</span>

        <span class="n">expt_id_multi</span> <span class="o">=</span> <span class="n">stamp_expt_multiedge</span><span class="p">(</span><span class="n">base_feature_list</span><span class="p">,</span> <span class="n">atlas</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="p">,</span> <span class="n">node_size</span><span class="p">,</span>
                                             <span class="n">weight_method</span><span class="p">)</span>
        <span class="n">out_path_multigraph</span> <span class="o">=</span> <span class="n">make_output_path_graph</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span>
                                                     <span class="p">[</span><span class="n">expt_id_multi</span><span class="p">,</span> <span class="s1">&#39;multigraph&#39;</span><span class="p">])</span>
        <span class="c1"># skipping the computation if the file exists already</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite_results</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">out_path_multigraph</span><span class="p">)</span> <span class="ow">and</span> <span class="n">getsize</span><span class="p">(</span>
                <span class="n">out_path_multigraph</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Multigraph exists already at</span><span class="se">\n\t</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
                  <span class="s1">&#39; skipping its computation!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out_path_multigraph</span><span class="p">))</span>
            <span class="n">multigraph</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># signal to re-read</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multigraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">base_feature</span> <span class="ow">in</span> <span class="n">base_feature_list</span><span class="p">:</span>
                <span class="c1"># # TODO refactor</span>
                <span class="c1"># unigraph, weight_vec = compute_unigraph(input_dir, subject, base_feature, weight_method, roi_labels,</span>
                <span class="c1">#                                         atlas, smoothing_param, node_size, centroids,</span>
                <span class="c1">#                                         num_bins, edge_range_dict,</span>
                <span class="c1">#                                         out_dir, overwrite_results, pretty_print_options)</span>
                <span class="c1"># if return_results:</span>
                <span class="c1">#     edge_weights_all[(weight_method, base_feature, subject)] = weight_vec</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">features</span> <span class="o">=</span> <span class="n">import_features</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span>
                                               <span class="p">[</span><span class="n">subject</span><span class="p">,</span> <span class="p">],</span>
                                               <span class="n">base_feature</span><span class="p">,</span>
                                               <span class="n">fwhm</span><span class="o">=</span><span class="n">smoothing_param</span><span class="p">,</span>
                                               <span class="n">atlas</span><span class="o">=</span><span class="n">atlas</span><span class="p">)</span>

                <span class="k">except</span><span class="p">:</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to read </span><span class="si">{}</span><span class="s1"> features&#39;</span>
                                  <span class="s1">&#39; for </span><span class="si">{}</span><span class="se">\n</span><span class="s1"> Skipping it.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base_feature</span><span class="p">,</span> <span class="n">subject</span><span class="p">),</span>
                                  <span class="ne">UserWarning</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="n">data</span><span class="p">,</span> <span class="n">rois</span> <span class="o">=</span> <span class="n">mask_background_roi</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="n">subject</span><span class="p">],</span> <span class="n">roi_labels</span><span class="p">,</span>
                                                               <span class="n">cfg</span><span class="o">.</span><span class="n">null_roi_name</span><span class="p">)</span>

                <span class="c1"># unique stamp for each subject and weight</span>
                <span class="n">expt_id_single</span> <span class="o">=</span> <span class="n">stamp_expt_weight</span><span class="p">(</span><span class="n">base_feature</span><span class="p">,</span> <span class="n">atlas</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="p">,</span>
                                                                 <span class="n">node_size</span><span class="p">,</span> <span class="n">weight_method</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Processing id {:</span><span class="si">{id_width}</span><span class="s1">} --&#39;</span>
                                 <span class="s1">&#39; weight {:</span><span class="si">{wtname_width}</span><span class="s1">} ({:</span><span class="si">{nd_wm}</span><span class="s1">}/{:</span><span class="si">{nd_wm}</span><span class="s1">})&#39;</span>
                                 <span class="s1">&#39; :&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">weight_method</span><span class="p">,</span> <span class="n">ww</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_weights</span><span class="p">,</span>
                                             <span class="n">nd_id</span><span class="o">=</span><span class="n">nd_id</span><span class="p">,</span> <span class="n">nd_wm</span><span class="o">=</span><span class="n">nd_wm</span><span class="p">,</span> <span class="n">id_width</span><span class="o">=</span><span class="n">max_id_width</span><span class="p">,</span>
                                             <span class="n">wtname_width</span><span class="o">=</span><span class="n">max_wtname_width</span><span class="p">))</span>

                <span class="c1"># actual computation of pair-wise features</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">unigraph</span> <span class="o">=</span> <span class="n">hiwenet</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                               <span class="n">rois</span><span class="p">,</span>
                                               <span class="n">weight_method</span><span class="o">=</span><span class="n">weight_method</span><span class="p">,</span>
                                               <span class="n">num_bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
                                               <span class="n">edge_range</span><span class="o">=</span><span class="n">edge_range_dict</span><span class="p">[</span><span class="n">base_feature</span><span class="p">],</span>
                                               <span class="n">return_networkx_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># retrieving edge weights</span>
                    <span class="n">weight_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">unigraph</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                    <span class="n">warn_nan</span><span class="p">(</span><span class="n">weight_vec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">return_results</span><span class="p">:</span>
                        <span class="n">edge_weights_all</span><span class="p">[(</span><span class="n">weight_method</span><span class="p">,</span> <span class="n">base_feature</span><span class="p">,</span> <span class="n">subject</span><span class="p">)]</span> <span class="o">=</span> <span class="n">weight_vec</span>

                <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">runexc</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">runexc</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exiting on keyborad interrupt! </span><span class="se">\n</span><span class="s1">&#39;</span>
                          <span class="s1">&#39;Abandoning the remaining processing &#39;</span><span class="p">)</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unable to extract </span><span class="si">{}</span><span class="s1"> weights for </span><span class="si">{}</span><span class="s1"> for </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weight_method</span><span class="p">,</span>
                                                                              <span class="n">base_feature</span><span class="p">,</span>
                                                                              <span class="n">subject</span><span class="p">))</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>

                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>

                <span class="c1"># TODO consider extracting some network features upon user request.</span>

                <span class="n">add_nodal_positions</span><span class="p">(</span><span class="n">unigraph</span><span class="p">,</span> <span class="n">centroids</span><span class="p">)</span>
                <span class="n">save_per_subject_graph</span><span class="p">(</span><span class="n">unigraph</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">expt_id_single</span><span class="p">)</span>

                <span class="c1"># adding edges/weights from each feature to a multigraph</span>
                <span class="c1"># this also encodes the sources</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">unigraph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="n">multigraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
                                        <span class="n">weight</span><span class="o">=</span><span class="n">unigraph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">],</span>
                                        <span class="n">base_feature</span><span class="o">=</span><span class="n">base_feature</span><span class="p">)</span>

            <span class="c1"># adding position info to nodes (for visualization later)</span>
            <span class="n">add_nodal_positions</span><span class="p">(</span><span class="n">multigraph</span><span class="p">,</span> <span class="n">centroids</span><span class="p">)</span>
            <span class="n">save_graph</span><span class="p">(</span><span class="n">multigraph</span><span class="p">,</span> <span class="n">out_path_multigraph</span><span class="p">,</span> <span class="s1">&#39;multi-edge&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">stat_func</span><span class="p">,</span> <span class="n">stat_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">summary_stats</span><span class="p">,</span> <span class="n">summary_stat_names</span><span class="p">):</span>
            <span class="c1"># creating single graph with a summary edge weight (like median)</span>
            <span class="n">out_path_summary</span> <span class="o">=</span> <span class="n">make_output_path_graph</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span>
                                                      <span class="p">[</span><span class="n">expt_id_multi</span><span class="p">,</span> <span class="n">stat_name</span><span class="p">,</span> <span class="s1">&#39;multigraph&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite_results</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">out_path_summary</span><span class="p">)</span> <span class="ow">and</span> <span class="n">getsize</span><span class="p">(</span><span class="n">out_path_summary</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;Summary </span><span class="si">{}</span><span class="s1"> of multigraph exists already at</span><span class="se">\n\t</span><span class="si">{}</span><span class="se">\n</span><span class="s1"> skipping its computation!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">stat_name</span><span class="p">,</span> <span class="n">out_path_summary</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">multigraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">multigraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_graphml</span><span class="p">(</span><span class="n">out_path_multigraph</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">summary_multigraph</span> <span class="o">=</span> <span class="n">summarize_multigraph</span><span class="p">(</span><span class="n">multigraph</span><span class="p">,</span> <span class="n">stat_func</span><span class="p">)</span>
                    <span class="n">add_nodal_positions</span><span class="p">(</span><span class="n">summary_multigraph</span><span class="p">,</span> <span class="n">centroids</span><span class="p">)</span>
                    <span class="n">save_graph</span><span class="p">(</span><span class="n">summary_multigraph</span><span class="p">,</span> <span class="n">out_path_summary</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> summary&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stat_name</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Summary </span><span class="si">{}</span><span class="s1"> could not be computed - skipping!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stat_name</span><span class="p">))</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">edge_weights_all</span>


<span class="k">def</span> <span class="nf">summarize_multigraph</span><span class="p">(</span><span class="n">multigraph</span><span class="p">,</span> <span class="n">func_summary</span><span class="p">):</span>
    <span class="s2">&quot;Creating single graph with a summary edge weight (like median)&quot;</span>

    <span class="n">summary_multigraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">multigraph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="c1"># looping through parallel edges and obtaining their weights.</span>
        <span class="n">all_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edge_item</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">edge_item</span> <span class="ow">in</span> <span class="n">multigraph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="n">summary_weight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">func_summary</span><span class="p">(</span><span class="n">all_weights</span><span class="p">))</span>  <span class="c1"># float needed due to graphml limitation</span>
        <span class="n">summary_multigraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">summary_weight</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_multigraph</span>


<span class="k">def</span> <span class="nf">add_nodal_positions</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">centroids</span><span class="p">):</span>
    <span class="s2">&quot;Adds the x, y, z attributes to each node in graph.&quot;</span>

    <span class="c1"># adding position info to nodes (for visualization later)</span>
    <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="n">centroids</span><span class="p">:</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">roi</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="n">roi</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">roi</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="n">roi</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">roi</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="n">roi</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span>


<span class="k">def</span> <span class="nf">save_summary_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span>
                       <span class="n">str_suffix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">summary_descr</span><span class="o">=</span><span class="s1">&#39;summary&#39;</span><span class="p">):</span>
    <span class="s2">&quot;Saves the features to disk.&quot;</span>

    <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get outpath returned from hiwenet, based on dist name and all other parameters</span>
        <span class="c1"># choose out_dir name  based on dist name and all other parameters</span>
        <span class="n">out_subject_dir</span> <span class="o">=</span> <span class="n">pjoin</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">subject</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pexists</span><span class="p">(</span><span class="n">out_subject_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">out_subject_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">str_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_file_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_multigraph_graynet.graphml&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">str_suffix</span><span class="p">,</span> <span class="n">summary_descr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_file_name</span> <span class="o">=</span> <span class="s1">&#39;_</span><span class="si">{}</span><span class="s1">_multigraph_graynet.graphml&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">summary_descr</span><span class="p">)</span>

        <span class="n">out_weights_path</span> <span class="o">=</span> <span class="n">pjoin</span><span class="p">(</span><span class="n">out_subject_dir</span><span class="p">,</span> <span class="n">out_file_name</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">write_graphml</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">out_weights_path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Saved the summary multi-graph to </span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out_weights_path</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Unable to save summary multi-graph to </span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out_weights_path</span><span class="p">))</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>

    <span class="k">return</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Pradeep Reddy Raamana.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>